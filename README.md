    
    消息队列系统的模块划分: 总体分为三部分: 服务端，发布客户端，订阅客户端
        1. 服务端
            A. 数据管理模块
                a.交换机数据管理模块: 描述了一个交换机应该有什么数据
                    数据管理:
                        1.交换机名称: 唯一标识
                        2.交换机类型: 决定了消息的转发消息
                            每个队列绑定中都有一个binding_key, 每条消息中都有一个routing_key
                            a. 直接交换: binding_key与routing_key相同，则消息放入队列中
                            b. 广播交换: 将消息放入交换机绑定的所有队列中
                            c. 主题交换: routing_key与多个绑定队列中的binding_key有个匹配规则，匹配成功了就放入
                        3.持久化标志: 决定了当前交换机信息是否需要持久化存储
                        4.自动删除标志: 关联了当前交换机的所有客户端都退出了，是否要自动删除交换机
                        5.交换机的其他参数: 当前未使用
                    对交换机的管理操作:
                        1.创建交换机: 本质上需要的是声明 --- 强断言的思想，有就ok，没有则创建的意思
                        2.删除交换机: 每个交换机都会绑定一个或多个队列(意味着会有一个或多个绑定信息)，因此删除交换机，需要删除相关的绑定信息
                        3.获取指定名称交换机
                        4.获取当前交换机的数量
                b.队列数据管理模块
                    数据管理: 
                        1.队列名称: 唯一标识
                        2.持久化存储标志: 决定了是否将队列消息持久化存储起来，决定重启后，这个队列是否还存在，也决定了队列中的消息是否持久化
                        3.是否独占标志: 只要当前客户端自己能够订阅这个队列，其他的不行
                        4.自动删除标志: 当订阅的客户端都退出后，是否删除这个队列
                        5.其他参数
                    操作管理: 增删查
                        1.创建队列
                        2.删除队列
                        3.获取指定队列信息
                        4.获取队列数量
                        5.获取所有队列名称: 当系统重启后，需要重新加载数据，加载历史消息，而加载消息需要知道队列名称
                c.绑定数据管理模块
                    数据管理:
                        1.交换机名称
                        2.队列名称
                        3.binding_key: 绑定密钥 --- 决定了交换的主题交换&直接交换的消息发布匹配规则
                    操作管理:
                        1.添加绑定
                        2.解除绑定
                        3.获取交换机相关的所有绑定信息: 删除交换机时，要删除删除信息   当消息发布到交换机时，交换机需要知道将消息发送到哪一个队列
                        4.获取队列相关的所有绑定信息
                        5.获取绑定数量
                d.消息数据管理模块
                    数据管理: 队列和消息
                        1.ID: 消息的唯一标识
                        2.持久化标志
                        3.routing_key
                        4.存储偏移量: 消息以队列为单元存储在文件中，这个偏移量，是当前消息相对于文件的起始位置
                        5.消息长度: 解决粘包问题
                        6.是否有效标志: 删除一个消息并不是用后面的消息向前覆盖，而是设置一个标志位，到最后的垃圾回收时统一删除
                    
                        1.消息链表: 保存所有的待推送消息
                        2.待确认消息hash: 消息推送给客户端后，会等待客户端进行消息确认，收到确认消息后，才会真正删除消息
                        3.持久化消息hash: 假设消息都会进行持久化存储，那么操作过程中就会存在垃圾回收操作，但是垃圾回收操作会改变消息的存储位置，因此每次垃圾回收后都需要用消息的新位置更新持久化消息中的消息位置
                            垃圾回收: 将有效的消息读取出来，然后重新截断文件，将消息连续写入到文件中(都是有效消息)
                        4.持久化的有效消息数量
                        5.持久化的总的消息数量: 决定了什么时候进行垃圾回收(有效/总的 > 50%  )
                    操作管理:
                        1.向队列新增消息
                        2.获取队首消息: 获取消息后，就会将消息从待推送消息链表中删除(不再是待发送，而是待确认)，加入到待确认消息链表中
                        3.确认消息: 从待确认消息中移除，并进行删除
                        4.恢复队列历史消息: 主要是在构造函数中进行(只有在重启的时候才会进行)
                        5.垃圾回收
                        6.删除队列相关消息文件
                    对外提供接口:
                        1.初始化队列消息结构
                        2.移除队列消息结构
                        3.向队列新增消息
                        4.对队列消息进行确认
                        5.恢复队列历史消息
                以上四个模块分别实现了数据的管理(增删查)，以及持久化的存储
            B. 虚拟机数据管理模块
                虚拟机其实就是交换机+队列+绑定+消息的整体逻辑单元
                因此虚拟机的数据管理其实就是将上面的四个模块的合并管理
                    数据管理:
                        1.交换机数据管理句柄
                        2.队列数据管理句柄
                        3.绑定信息数据管理句柄
                        4.消息数据管理句柄
                    操作管理:
                        1.声明/删除交换机
                        2.声明/删除队列
                        3.队列的绑定/解除绑定
                        4.获取指定队列的消息
                        5.对指定队列的指定消息进行确认
                        6.获取交换机相关的所有绑定信息
            C. 交换路由模块
                消息的发布，将一条新消息发布到交换机上，由交换机决定放入到那个队列当中，而决定交给哪个队列，其中交换机的类型起很大的作用(直接交换，广播交换，主题交换)
            D. 消费者管理模块
                消费者指的是订阅了一个队列消息的客户端，一旦这个消息队列有了消息就会推送给这个客户端
                在核心的API中有个订阅消息的服务 --- 注意: 这里的订阅不是订阅某条消息，而是订阅了某个队列的消息
                当前主要实现了消息推送的功能，因此一旦有了消息就要能找到消费者相关的信息(消费者对应的信道)
                    消费者信息:
                        1.消费者标识
                        2.订阅队列名称: 当当前这个队列有消息时，就会进行推送; 当客户端收到消息时，需要对指定队列的消息进行确认
                        3.自动确认标志: 自动确认 --- 推送消息后，直接删除消息; 手动确认 --- 推送消息后，需要等到收到确认回复后再删除
                        4.消费者处理回调函数指针: 队列有消息后，通过那个函数进行处理(向指定客户端推送消息)
                    消费者管理: 以队列为单元进行管理
                        每个消费者订阅的都是指定队列的消息，消费者对消息进行确认也是以队列进行确认
                        最关键的是:当指定队列中有消息了，必然是获取订阅了这个队列的消费者信息进行消息推送
                    队列消费者管理结构:
                        数据信息: 消费者链表---保存当前队列的所有消费者信息(RR轮转每次取出下一个消费者进行消息推送，一个消息只需要被一个客户端处理)
                        管理操作: 
                            1.新增消费者
                            2.RR轮转获取一个消费者
                            3.删除
                            4.数量
                            5.是否为空
                    管理操作:
                        1.初始化队列消费者结构
                        2.删除队列消费者结构
                        3.向指定队列添加消费者
                        4.获取指定队列消费者
                        5.删除指定队列消费者
            E. 信道(通信通道)管理模块
                为什么要有这个呢? 因此一个连接可能会对应有多个通信通道
                一旦某个客户端要关闭通信，关闭的不是连接，而是自己对应的通信信道，关闭信道我们就需要将客户端的订阅给取消

                信道是网络通信中的一个概念，叫做通信通道。
                    网络通信的时候，必然都是通过网络通信连接来完成的，为了能够更加充分的利用资源，因此对通信连接又进行了进一步的细化，细化出了通信通道对于用户来说，一个通信通道，就是进行网络通信的载体，而一个真正的通信连接，可以创建出多个通信通道每一个信道之间，在用户的眼中是相互独立的，而在本质的底层它们使用同一个通信连接进行网络通信。
                因此，因为信道是用户眼中的一个通信通道，所以所有的网络通信服务都是由信道提供的。
                    信道提供的服务操作:
                        1.声明/删除交换机
                        2.声明/删除队列
                        3.绑定/解绑队列与交换机
                        4.发布消息/订阅队列消息/取消订阅/队列消息确认
                    信道要管理的数据: 
                        0.信道ID
                        1.信道关联的虚拟机句柄:
                        2.信道关联的消费者句柄:当信道关闭的时候，所有关联的消费者订阅都要取消，相当于删除所有的相关消费者。3.工作线程池句柄:信道进行了消息发布到指定队列操作之后;从指定队列获取一个消费者，对这条消息进行消费。也就是将这条消息推送给一个客户端的操作交给线程池执行。并非每个信道都有一个线程池，而是整个服务器有一个线程池，大家所有的信道都是通过同一个线程池进行异步操作而已
                    信道的管理:
                        1.创建一个信道
                        2.关闭一个信道
                        3.获取指定信道句柄
            F. 连接管理模块
                就是一个网络通信对应的连接，当一个连接要关闭的时候，就应该把连接关联的信道全部关闭，因此数据管理至少要管理关联的信道
                概念: 网络通信连接在网络通信模块中，我们使用muduo库来实现底层通信，muduo库中本身就有Connection连接的概念和对象类但是我们的连接中，还有一个上层通信信道的概念，这个概念在muduo库中是没有的。因此，我们需要在用户的层面，对这个muduo库中的Connection连接进行二次封装。形成我们自己所需的连接管理。
                    管理数据:
                        1.muduo库的通信连接
                        2.当前连接关联的信道管理句柄
                    连接提供的操作:
                        1.创建信道
                        2.关闭信道
                    管理的操作:
                        1.新增连接
                        2.关闭连接
                        3.获取指定连接信息
            G. 服务端BrokerServer模块
                这个模块是对以上所有的模块的整合，整合成为一个服务器
                Broker服务器模块:
                这个模块是一个功能整合模块，本质上这个模块并不提供实质的功能性操作。这个模块最重要的是资源的整合，是一个资源的载体
                    1.一个服务器有一个工作线程池， 其他所有的信道操作的都是这同一个线程池2.一个服务器有一个虚拟机，其他所有交换机，队列，绑定，消息的操作都是针对这个虚拟机进行的
                    3.一个服务器有一个消费者管理,
                    4.通信相关连接管理，协议处理模块句柄，也是一整个服务器有一套。
        2. 客户端
            A. 消费者管理模块
                一个订阅客户端，当订阅一个队列消息的时候，其就相当于建立了一个消费者
            B. 信道管理模块
                客户端的信道与服务端的信道是一一对应的，服务端信道提高的服务，客户端都有，相当于，服务端为客户端提供服务，客户端为用户提供服务
            C. 连接管理模块
                对于用户来说，所有的服务都是通过信道来完成的，信道在用户的角度就是一个通信通道(而不是连接),因此所有的请求都是通过信道来完成的
                连接的管理就包含了客户端资源的整合
            D. 基于以上的三个模块封装实现: 订阅客户端/发布客户端
                订阅客户端: 订阅一个队列的消息，收到推送过来的消息进行处理
                发布客户端: 向一个交换机发布消息









    C++11 线程池实现
        a. 基于线程池执⾏任务的时候，⼊⼝函数内部执⾏逻辑是固定的，因此选择std::packaged_task加上std::future的组合来实现。
        b. 线程池的⼯作思想：⽤⼾传⼊要执⾏的函数，以及需要处理的数据（函数的参数）,由线程池中的⼯作线程来执⾏函数完成任务
            · 管理的成员:
                · 任务池：⽤vector维护的⼀个函数任务池⼦
                · 互斥锁 & 条件变量： 实现同步互斥
                · ⼀定数量的⼯作线程：⽤于不断从任务池取出任务执⾏任务
                · 结束运⾏标志：以便于控制线程池的结束
            · 管理的操作:
                · ⼊队任务：⼊队⼀个函数和参数
                · 停⽌运⾏：终⽌线程池
        
        补充:
            atomic: 保证原子性的一个类型   condition_variable: 环境变量


















    项目涉及的内容：
        1. protobuf: 用于进行序列化和反序列化    详解见博客: https://blog.csdn.net/qq_62321047/article/details/140466202
            a. 编写proto文件，描述我们想要定义的结构化对象，描述对象中，有什么样的成员，每个成员具有什么样的属性
            比如: 在proto文件中描述一个学生结构体:
                    姓名: 是一个字符串     学号: 是一个长整型    年龄: 整形
            b. 编译proto文件
                针对proto文件中的描述，生成一份我们所需要的对应语言的结构化对象数据操作代码
                .h文件中定义了我们所描述的数据结构体对象;  .cc中定义实现了结构化对象数据的访问&操作&序列化&反序列化
            c. 使用: 引入生成的头文件，在代码中根据需要使用即可
            d. 语法规则:
                1> 声明语法版本: syntax = "proto3"; 
                2> 声明命名空间名称: package name;
                3> 定义结构体对象描述
        
        2. muduo库: 
            a. 基于主从reator模型的高性能服务器框架
                reator模型: 基于事件触发的模型(基于epoll进行IO事件监控)
                主从reator模型: 将IO事件监控进一步进行了层次划分
                主reator: 只对新建立事件进行监控(保证不受IO阻塞影响实现高效的新建连接获取)
                从reator: 针对新建连接进行IO事件监控(进行IO操作和业务处理)
                主从reator必然是一个多执行流的并发模式 —— one thread ont loop, 一个事件监控, 占据一个线程, 进行事件监控
            b. 
            
        3. SQLLite3
            sqlite3操作流程：
                a. 查看当前数据库在编译阶段是否启动了线程安全
                    int sqlite3_threadsafe()； 0-未启⽤； 1-启⽤
                    需要注意的是sqlite3是有三种安全等级的：
                        1. ⾮线程安全模式
                        2. 线程安全模式（不同的连接在不同的线程/进程间是安全的，即⼀个句柄不能⽤于多线程间）
                        3. 串⾏化模式（可以在不同的线程/进程间使⽤同⼀个句柄）
                b. 创建/打开数据库⽂件，并返回操作句柄
                    int sqlite3_open(const char *filename, sqlite3 **ppDb) 成功返回SQLITE_OK, 若在编译阶段启动了线程安全，则在程序运⾏阶段可以通过参数选择线程安全等级.
                    int sqlite3_open_v2(const char *filename, sqlite3 **ppDb, int flags, const char *zVfs );
                        flag: 
                            SQLITE_OPEN_READWRITE -- 以可读可写⽅式打开数据库⽂件
                            SQLITE_OPEN_CREATE -- 不存在数据库⽂件则创建
                            SQLITE_OPEN_NOMUTEX--多线程模式，只要不同的线程使⽤不同的连接即可保证线程安全
                            SQLITE_OPEN_FULLMUTEX--串⾏化模式
                        返回：SQLITE_OK表示成功
                c. 执⾏语句
                    int sqlite3_exec(sqlite3*, char *sql, int (*callback)(void*,int,char**,char**), void* arg, char **err)
                    int (*callback)(void*,int,char**,char**)
                        void* : 是设置的在回调时传⼊的arg参数
                        int：⼀⾏中数据的列数
                        char**：存储⼀⾏数据的字符指针数组
                        char**：每⼀列的字段名称
                    这个回调函数有个int返回值，成功处理的情况下必须返回0，返回⾮0会触发ABORT退出程序
                    返回：SQLITE_OK表⽰成功
                d. 销毁句柄
                    int sqlite3_close(sqlite3* db); 成功返回SQLITE_OK
                    int sqlite3_close_v2(sqlite3*); 推荐使⽤--⽆论如何都会返回SQLITE_OK, 获取错误信息
                    const char *sqlite3_errmsg(sqlite3* db);

        4. gtest:
            a. 简单的宏断言
            b. 事件机制
                测试中，可以有多个测试套件(包含一组单元测试)   
                测试套件: 可以理解为一个测试环境，可以在单元测试之前进行测试环境初始化，测试完毕后进行测试环境清理

                全局测试套件: 在整体的测试中，只会初始化一次环境，在所有测试用例完毕后，才会清理环境
                用例测试套件: 在每次的单元测试中，都会重新初始化测试环境，完毕后清理环境

                全局事件：针对整个测试程序。实现全局的事件机制，需要创建⼀个⾃⼰的类，然后继承testing::Environment类，然后分别实现成员函数 SetUp 和 TearDown ，同时在main函数内进⾏调⽤ testing::AddGlobalTestEnvironment(new MyEnvironment); 函数添加全局的事件机制
                class HashTestEnv : public testing::Environment {
                public:
                    virtual void SetUp() override {     -----------------> 在所有单元测试运行前执行的接口，常用于对测试环境进行初始化
                        std::cout << "测试前:提前准备数据!!\n";
                        dict.insert(std::make_pair("Hello", "你好"));
                    }

                    virtual void TearDown() override {    ---------------> 在所有单元测试结束完毕后执行的接口，完成测试环境的清理
                        std::cout << "测试结束后:清理数据!!\n";
                        dict.clear();
                    }
                };

                独立测试套件: 测试环境类中，可以定义成员变量，成员变量是独立的，是与当前测套件相关的单元测试才能访问
                class HashTestEnv1 : public testing::Test {
                public:
                    static void SetUpTestCase() {
                    std::cout << "环境1第⼀个TEST之前调⽤\n";
                    }

                    static void TearDownTestCase() {
                    std::cout << "环境1最后⼀个TEST之后调⽤\n";
                    }
                public:
                    std::unordered_map<std::string, std::string> dict;
                };

                TEST_F(HashTestEnv1, insert_test) {
                    std::cout << "环境1,中间insert测试\n";
                    dict.insert(std::make_pair("Hello", "你好"));
                    auto it = dict.find("hello");
                    ASSERT_NE(it, dict.end());
                }
                注意: 单元测试宏，已经变成了TEST_F，测试的命令，必须与套件环境类名一致(在单元测试宏函数中，能够直接访问类成员变量)
        C++同步异步: 
            package_task的使用: 
                package_task 是一个模板类，实例化的对象可以对一个函数进行二次封装，package_task 可以通过get_future获取一个future对象，来获取封装的这个函数的异步执行操作
                